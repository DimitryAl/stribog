package stribog

func KeySchedule(K *[]byte, i int) {

	AddXor512(K, &C[i], K)
	S_transformation(K)
	P_transformation(K)
	L_transformation(K)

}

func Compression_E(K, m, state *[]byte) {

	AddXor512(m, K, state)

	for i := 0; i < 12; i++ {
		S_transformation(state)
		P_transformation(state)
		L_transformation(state)
		KeySchedule(K, i)
		AddXor512(state, K, state)
	}

}

func g_N(N, h, m *[]byte) {

	var t, K []byte
	K = make([]byte, 64)
	t = make([]byte, 64)

	AddXor512(N, h, &K)
	S_transformation(&K)
	P_transformation(&K)
	L_transformation(&K)
	Compression_E(&K, m, &t)

	AddXor512(&t, h, &t)
	AddXor512(&t, m, h)

}

func hash_X(IV, message, out *[]byte, length uint64) {

	var v512 []byte = []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00}
	var v0 []byte = []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	var Sigma []byte = []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	var N []byte = []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	var m = make([]byte, 64)
	hash := IV
	var len_ = length

	// Stage 2

	var temp1 uint64
	for len_ >= 512 {
		//memcpy(m, message + len/8 - 63 - ( (len & 0x7) == 0 ), 64);

		//((len_&0x7) == 0)
		if len_%8 == 0 {
			temp1 = 1
		} else {
			temp1 = 0
		}
		temp2 := len_/8 - 63 - temp1
		for i := 0; i < 64; i++ {
			m[i] = (*message)[i+int(temp2)]
		}
		g_N(&N, hash, &m)
		AddModulo512(&N, &v512, &N)
		AddModulo512(&Sigma, &m, &Sigma)
		len_ -= 512
	}

	memset := func(arr []byte, value byte, n int) {
		for i := 0; i < n; i++ {
			arr[i] = value
		}
	}
	memset(m, 0, 64)

	//memcpy(m + 63 - len/8 + ( (len & 0x7) == 0 ), message, len/8 + 1 - ( (len & 0x7) == 0 ));
	if len_%8 == 0 {
		temp1 = 1
	} else {
		temp1 = 0
	}

	temp2 := 63 - len_/8 + temp1
	temp3 := len_/8 + 1 - temp1

	//memcpy
	for i := temp2; i < temp2+temp3; i++ {
		m[i] = (*message)[i]
	}

	// Stage 3

	//len & 0x7
	if len_%8 == 0 {
		temp1 = 1
	} else {
		temp1 = 0
	}
	m[63-len_/8] |= (1 << (temp1))

	g_N(&N, hash, &m)
	// Что-то не странное
	v512[63] = byte(len_) & 0xFF
	v512[62] = byte(len_ >> 8)
	AddModulo512(&N, &v512, &N)

	AddModulo512(&Sigma, &m, &Sigma)

	g_N(&v0, hash, &N)
	g_N(&v0, hash, &Sigma)

	for i := 0; i < 64; i++ {
		(*out)[i] = (*hash)[i]
	}
}

func Hash_512(message *[]byte, length uint64, out *[]byte) {

	var IV []byte = []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00}

	hash_X(&IV, message, out, length)
}

func Hash_256(message *[]byte, length uint64, out *[]byte) {
	var IV []byte = []byte{
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	}

	var hash []byte
	hash = make([]byte, 64)

	hash_X(&IV, message, &hash, length)

	for i := 0; i < 32; i++ {
		(*out)[i] = hash[i]
	}
}
